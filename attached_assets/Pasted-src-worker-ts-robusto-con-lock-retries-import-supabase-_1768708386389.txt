src/worker.ts (robusto con lock + retries)
import { supabase } from "./db";
import { config } from "./config";
import { processLeadJob } from "./jobs/processLeadJob";

function nowIso() {
  return new Date().toISOString();
}

function isExpiredLock(lockedAt: string | null, ttlSeconds: number) {
  if (!lockedAt) return true;
  const t = new Date(lockedAt).getTime();
  return Date.now() - t > ttlSeconds * 1000;
}

export async function runWorker(instanceId: string) {
  // 1) Coge candidatos (pending o processing stale)
  const { data: candidates, error } = await supabase
    .from("leads_jobs")
    .select("*")
    .in("status", ["pending", "processing"])
    .order("created_at", { ascending: true })
    .limit(config.batchSize * 3);

  if (error) throw error;
  if (!candidates || candidates.length === 0) return { processed: 0 };

  // 2) Filtra por lock TTL y bloquea batch
  const toLock = candidates
    .filter((j: any) => isExpiredLock(j.locked_at ?? null, config.lockTtlSeconds))
    .slice(0, config.batchSize);

  if (toLock.length === 0) return { processed: 0 };

  // 3) Lock atómico “best effort”
  let processed = 0;
  for (const job of toLock) {
    const { data: locked, error: lockErr } = await supabase
      .from("leads_jobs")
      .update({
        status: "processing",
        locked_at: nowIso(),
        locked_by: instanceId,
        updated_at: nowIso(),
      })
      .eq("id", job.id)
      .or("locked_at.is.null,locked_at.lt." + new Date(Date.now() - config.lockTtlSeconds * 1000).toISOString())
      .select("*")
      .maybeSingle();

    if (lockErr || !locked) continue;

    try {
      await processLeadJob(locked);
      processed++;
    } catch (e: any) {
      const msg = (e?.message ?? String(e)).slice(0, 1500);

      await supabase
        .from("leads_jobs")
        .update({
          status: "failed",
          last_error: msg,
          attempts: (locked.attempts ?? 0) + 1,
          updated_at: nowIso(),
        })
        .eq("id", locked.id);
    }
  }

  return { processed };
}